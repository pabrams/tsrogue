#+title: r/roguelikedev summer tutorial
#+date: <2020-06-18 Thu>

I had previously followed the r/roguelikedev summer tutorial series, using Rust, with the goal of learning Rust. I got halfway through. 
I learned a lot of Rust. In part I gave up because Rust frustrated me, especially with libtcod.
This year I decided that instead to use a language I already know, Javascript. I'll use [[https://ondras.github.io/rot.js/hp/][rot.js]].

#+begin_export html
<figure>
  <div id="game"/>
  <div id="focus-reminder">click game to focus</div>
</figure>
#+end_export

Source code: [[href:roguelike-dev.js][roguelike-dev.js]]

* Getting started

HTML:

#+begin_src xml
<figure id="game"></figure>
<script src="https://unpkg.com/rot-js"></script>
<script src="game.js"></script>
#+end_src

Javascript:

#+begin_src js
const display = new ROT.Display({width: 60, height: 25, 
                                 fontFamily: 'Roboto Mono'});
document.getElementById('game')
        .appendChild(display.getContainer());
display.draw(5, 4, '@');
#+end_src

[[./screenshots/1.png]]

* Keyboard input

There are various places I could attach an event handler. 

- The [[https://ondras.github.io/rot.js/manual/#keyboard][rot.js manual]] suggests using an ~<input>~ element for event handlers. I decided not to do this. If that input ever loses focus, I don't know how to get focus back. Clicking an input box is what I think of when I'm typing input text but not what I expect to do when moving around on the map.
- One [[http://www.roguebasin.roguelikedevelopment.org/index.php?title=Rot.js_tutorial,_part_1][rot.js tutorial]] attaches the event handlers to the global =window= object. I decided not to do this. There are times when I am typing elsewhere on the page (typing into the site search box, or adding a comment, or maybe even in-game actions like typing my name in). I don't want the game to treat those keystrokes as player actions.

I decided to instead make the game map focusable by adding the ~tabindex="1"~ attribute to its =canvas=. This way, clicking /on the game map/ will give it keyboard focus. You can click away to add a comment and then come back to the game.

Javascript:

#+begin_src js
const canvas = display.getContainer();
canvas.addEventListener('keydown', handleKeyDown);
canvas.setAttribute('tabindex', "1");
canvas.focus();
#+end_src

The problem is that a canvas isn't an obviously focusable element. What happens if it ever loses focus? I decided to add a message when the canvas loses focus:

HTML:

#+begin_src xml
<figure>
  <div id="game"/>
  <div id="focus-reminder">click game to focus</div>
</figure>
#+end_src

Javascript:

#+begin_src js
const focusReminder = document.getElementById('focus-reminder');
canvas.addEventListener('blur', () => { focusReminder.style.visibility = 'visible'; });
canvas.addEventListener('focus', () => { focusReminder.style.visibility = 'hidden'; });
#+end_src

CSS:

#+begin_src css
#game canvas { display: block; margin: auto; }
#+end_src

Here's what it looks like if it does not have focus:

[[./screenshots/2.png]]

The next thing I need is an event handler:

#+begin_src js
function handleKeyDown(event) {
    console.log('keydown', event);
}
#+end_src

I often start out with a =console.log= to make sure that a function is getting called. What's next? Let's move around.

Oh, I can't do that yet, because I don't have a player position.

* Moving around

I need to keep track of the player position and then change it when a key is pressed.

#+begin_src js
let player = {x: 5, y: 4, ch: '@'};

function drawCharacter(character) {
    let {x, y, ch} = character;
    display.draw(x, y, ch);
}

function draw() {
    drawCharacter(player);
}

function handleKeyDown(event) {
    if (event.keyCode === ROT.KEYS.VK_RIGHT) { player.x++; }
    if (event.keyCode === ROT.KEYS.VK_LEFT) { player.x--; }
    if (event.keyCode === ROT.KEYS.VK_DOWN) { player.y++; }
    if (event.keyCode === ROT.KEYS.VK_UP) { player.y--; }
    draw();
}

draw();
#+end_src

[[./screenshots/3.png]]

Two problems:

1. When using arrow keys, /the page scrolls/. I can fix this by adding =event.preventDefault()=. But if I do that, then browser hotkeys stop working. So I need to do something a little smarter. I'm going to prevent the default /only/ if I handled the key.
2. The =@= character doesn't get erased when you move. I need to either draw a space character over the old position, or I need to clear the game board and redraw everything. I'm going to redraw everything.

#+begin_src js
function handleKeyDown(event) {
    const actions = {
        [ROT.KEYS.VK_RIGHT]: () => { player.x++; },
        [ROT.KEYS.VK_LEFT]:  () => { player.x--; },
        [ROT.KEYS.VK_DOWN]:  () => { player.y++; },
        [ROT.KEYS.VK_UP]:    () => { player.y--; },
    };
    if (actions[event.keyCode]) {
        actions[event.keyCode]();
        event.preventDefault();
    }
    draw();
}

function draw() {
    display.clear();
    drawCharacter(player);
}
#+end_src

#+begin_export html
<x:footer>
  <style>
    #game canvas { display: block; margin: auto; }
    .figure img { border: 2px solid #999; box-shadow: 0 1px 2px 2px rgba(0,0,0,0.2); }
  </style>
  <script src="third-party/rot.js"/>
  <script src="roguelike-dev.js"/>
  <script src="prepare-screenshot.js"/>

  Created 18 Jun 2020; &#160;
  <!-- hhmts start -->Last modified: 20 Jun 2020<!-- hhmts end -->
</x:footer>
#+end_export
