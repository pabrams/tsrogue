#+title: r/roguelikedev summer tutorial
#+date: <2020-06-18 Thu>
#+options: toc:nil

I had previously followed the r/roguelikedev summer tutorial series, but never finished.
I'm trying again this year, using [[https://ondras.github.io/rot.js/hp/][rot.js]] this time.

#+begin_export html
<figure>
  <div id="status-bar"/>
  <div id="health-bar"/>
  <div id="health-text"/>
  <div id="inventory-overlay"/>
  <div id="messages"/>
  <div id="message-overlay"/>
  <div id="instructions"/>
</figure>
#+end_export

Source code: [[href:roguelike-dev.js][roguelike-dev.js]]

* Getting started

#+TOC: headlines 2

I'm going to follow the [[http://rogueliketutorials.com/tutorials/tcod/][Roguelike Tutorial for Python]] (2019 version, not the 2020 version, for various reasons) and adapt it for [[https://ondras.github.io/rot.js/hp/][rot.js]]. [[http://rogueliketutorials.com/tutorials/tcod/part-0/][Part 0]] of the tutorial covers setting up Python and libtcod. I'll instead set up rot.js.

HTML:

#+begin_src xml
<figure id="game"></figure>
<script src="https://unpkg.com/rot-js"></script>
<script src="game.js"></script>
#+end_src

Javascript:

#+begin_src js
const display = new ROT.Display({width: 60, height: 25});
document.getElementById('game')
        .appendChild(display.getContainer());
display.draw(5, 4, '@');
#+end_src

Set the =fontFamily= property if you want to override the default browser monospace font. For example, =fontFamily: "Roboto Mono"=.

[[./screenshots/1.png]]

A warning about my coding style: I follow /make it work before making the code nice/. That means I'll use plenty of global variables and hacks at first, and clean up some of them later. Don't look at my code as an example of how to structure a program "properly".

* Key input

[[http://rogueliketutorials.com/tutorials/tcod/part-1/][Part 1 of the roguelike tutorial]] covers setting up a screen and keyboard handler. I already set up the screen in the previous section so now I need to set up a keyboard handler. Unlike Python, we don't write an event loop in the browser. The browser already is running an event loop, and we add event handlers to it. 

There are various places to attach a keyboard event handler. 

- The [[https://ondras.github.io/rot.js/manual/#keyboard][rot.js manual]] suggests using an ~<input>~ element for event handlers. I decided not to do this. If that input ever loses focus, I don't know how to get focus back. Clicking an input box is what I think of when I'm typing input text but not what I expect to do when moving around on the map.
- One [[http://www.roguebasin.roguelikedevelopment.org/index.php?title=Rot.js_tutorial,_part_1][rot.js tutorial]] attaches the event handlers to the global =window= object. I decided not to do this. There are times when I am typing elsewhere on the page (typing into the site search box, or adding a comment, or maybe even in-game actions like typing my name in). I don't want the game to treat those keystrokes as player actions.

I decided to instead make the game map focusable by adding the ~tabindex="1"~ attribute to its =canvas=. This way, clicking /on the game map/ will give it keyboard focus. You can click away to add a comment and then come back to the game.

Javascript:

#+begin_src js
const canvas = display.getContainer();
canvas.addEventListener('keydown', handleKeyDown);
canvas.setAttribute('tabindex', "1");
canvas.focus();
#+end_src

The problem is that a canvas isn't an obviously focusable element. What happens if it ever loses focus? I decided to add a message when the canvas loses focus:

HTML:

#+begin_src xml
<figure>
  <div id="game"></div>
  <div id="focus-reminder">click game to focus</div>
</figure>
#+end_src

Javascript:

#+begin_src js
const focusReminder = document.getElementById('focus-reminder');
canvas.addEventListener('blur', () => { focusReminder.style.visibility = 'visible'; });
canvas.addEventListener('focus', () => { focusReminder.style.visibility = 'hidden'; });
#+end_src

CSS:

#+begin_src css
#game canvas { display: block; margin: auto; }
#+end_src

The CSS is not self-explanatory. I use =display: block= because a =<canvas>= element is /inline/ by default, and that means it has some extra space below it matching the extra space a line of text has below it to separate it from the next line below. I don't want that so I change it from an inline element to a block element. I use =margin: auto= to center the canvas in the parent element.

Here's what it looks like if it does not have focus:

[[./screenshots/2.png]]

The next thing I need is an event handler:

#+begin_src js
function handleKeyDown(event) {
    console.log('keydown', event);
}
#+end_src

I often start out with a =console.log= to make sure that a function is getting called.

What's next for Part 1? I need to make arrow keys move the player around. I can't do that yet, because I don't have a player position.

* Player movement

I need to keep track of the player position and then change it when a key is pressed.

#+begin_src js
let player = {x: 5, y: 4, ch: '@'};

function drawCharacter(character) {
    let {x, y, ch} = character;
    display.draw(x, y, ch);
}

function draw() {
    drawCharacter(player);
}

function handleKeyDown(event) {
    if (event.keyCode === ROT.KEYS.VK_RIGHT) { player.x++; }
    if (event.keyCode === ROT.KEYS.VK_LEFT)  { player.x--; }
    if (event.keyCode === ROT.KEYS.VK_DOWN)  { player.y++; }
    if (event.keyCode === ROT.KEYS.VK_UP)    { player.y--; }
    draw();
}

draw();
#+end_src

[[./screenshots/3.png]]

Two problems:

1. When using arrow keys, /the page scrolls/. I can fix this by adding =event.preventDefault()=. But if I do that, then browser hotkeys stop working. So I need to do something a little smarter. I'm going to prevent the default /only/ if I handled the key.
2. The =@= character doesn't get erased when I move. I need to either draw a space character over the old position, or I need to clear the game board and redraw everything. I'm going to redraw everything. I find it to be simpler and less error prone.

This would be a good time to mention that the rot.js interactive manual doesn't cover all the functionality. You may also want to look at [[https://ondras.github.io/rot.js/doc/][the non-interactive documentation]] for a more complete list of methods. In this case, I looked at [[https://ondras.github.io/rot.js/doc/classes/_display_canvas_.canvas.html][display/canvas→Canvas]] to find the =clear= method.

[[http://rogueliketutorials.com/tutorials/tcod/part-1/][Part 1]] of the Python tutorial splits up keyboard handling into a function that generates an /action/ and another function that /performs/ the action. I'll do the same.

#+begin_src js
function handleKeys(keyCode) {
    const actions = {
        [ROT.KEYS.VK_RIGHT]: () => ['move', +1, 0],
        [ROT.KEYS.VK_LEFT]:  () => ['move', -1, 0],
        [ROT.KEYS.VK_DOWN]:  () => ['move', 0, +1],
        [ROT.KEYS.VK_UP]:    () => ['move', 0, -1],
    };
    let action = actions[keyCode];
    return action ? action() : undefined;
}
    
function handleKeyDown(event) {
    let action = handleKeys(event.keyCode);
    if (action) {
        if (action[0] === 'move') {
            let [_, dx, dy] = action;
            player.x += dx;
            player.y += dy;
            draw();
        } else {
            throw `unhandled action ${action}`;
        }
        event.preventDefault();
    }
}

function draw() {
    display.clear();
    drawCharacter(player);
}
#+end_src

Ok, that's better. It only captures keys that are being used for the game, and leaves browser hotkeys alone. And it erases the screen before drawing a new frame.

What else is in Part 1 of the tutorial?

- fullscreen toggle
- press escape to quit

I'm going to skip these two.

* Entities

[[http://rogueliketutorials.com/tutorials/tcod/part-2/][Part 2]] of the tutorial covers entities. My design differs slightly from the tutorial:

1. I include only "instance" data in the entity, such as position and health, but not "static" data such as its color.
2. I include an entity type string instead. Normally this is "implicit" information in that each object belongs to a class. I prefer making /game/ classes explicit.
3. I also don't put methods in this object. I've had too many methods that don't "belong" in any one class, so I prefer to leave them as free functions. My goal is to have the object serializable as JSON.
4. I give each entity an id. I find that useful in debugging. It may come in handy later for serialization or events or logging.

#+begin_src js
function createEntity(type, x, y) {
    let id = ++createEntity.id;
    return { id, type, x, y };
}
createEntity.id = 0;

let player = createEntity('player', 5, 4);
#+end_src

Here's an example of how this design differs from the one in the Python tutorial:

#+begin_src js
function drawEntity(entity) {
    const visuals = {
        player: ['@', "hsl(60, 100%, 50%)"],
        troll: ['T', "hsl(120, 60%, 50%)"],
        orc: ['o', "hsl(100, 30%, 50%)"],
    };

    const [ch, fg, bg] = visuals[entity.type];
    display.draw(entity.x, entity.y, ch, fg, bg);
}
#+end_src

Instead of storing the character and the color /in the object/, I store a /type/ in the object, and then store the character and color in a lookup table. There are some scenarios where I like this design better:

- if I want to change the appearance based on its status (bleeding, poisoned, etc.)
- if I want to show another map (perhaps a sonar view) where the visuals of each entity are different
- if I save the game, and then in the new version of the game I want to change colors
- if I want to switch from ascii to graphical tiles

Ok, cool, I have a way to make entities. Let's make a second one:

#+begin_src js
let troll = createEntity('troll', 20, 10);
#+end_src

Now I have to modify the drawing function to draw it too:

#+begin_src js
function draw() {
    display.clear();
    drawEntity(player);
    drawEntity(troll);
}
#+end_src

[[./screenshots/4.png]]

Looks good. The player and monster have different appearances.

I can't keep adding a variable for each entity. Part 2 of the Roguelike Tutorial converts the individual entity variables into an set of entities. 
I was going to use an array or a Set but decided to use a Map instead.

#+begin_src js
let entities = new Map();
function createEntity(type, x, y) {
    let id = ++createEntity.id;
    let entity = { id, type, x, y };
    entities.set(id, entity);
    return entity;
}
createEntity.id = 0;
#+end_src

Then when I draw them, I can loop over entities:

#+begin_src js
function draw() {
    display.clear();
    for (let entity of entities.values()) {
        drawEntity(entity);
    }
}
#+end_src

* Map

The second half of [[http://rogueliketutorials.com/tutorials/tcod/part-2/][Part 2]] creates a map data structure, and Part 3 generates a dungeon map.  ROT.js includes dungeon map creation functions so I'll use one of their algorithms. ROT will call a callback function for each map tile, 0 for walkable and 1 for wall. I'm going to store this data in a Map, indexed by a string =x,y=. For example at position x=3, y=5, I'll use a string key ="3,5"=.

#+begin_src js
function createMap(width, height) {
    let map = {
        width, height,
        tiles: new Map(),
        key(x, y) { return `${x},${y}`; },
        get(x, y) { return this.tiles.get(this.key(x, y)); },
        set(x, y, value) { this.tiles.set(this.key(x, y), value); },
    };

    const digger = new ROT.Map.Digger(width, height);
    digger.create((x, y, contents) => map.set(x, y, contents));
    return map;
}
let map = createMap(60, 25);
#+end_src

The next step is to draw the map. I want to draw it first, before the player or monsters.

#+begin_src js
function draw() {
    display.clear();
    for (let y = 0; y < map.height; y++) {
        for (let x = 0; x < map.width; x++) {
            if (map.get(x, y)) {
                display.draw(x, y, '⨉', "hsl(60, 10%, 40%)", "gray");
            } else {
                display.draw(x, y, '·', "hsl(60, 50%, 50%)", "black");
            }
        }
    }
    for (let entity of entities.values()) {
        drawEntity(entity);
    }
}
#+end_src

[[./screenshots/5.png]]

The final step is to make player movement not allow moving onto a wall. I modified the movement function to check if the map tile is =0=. This is slightly different from checking that it's not =1= in that this will automatically makes sure I don't walk off the map, where the values are =undefined=.

#+begin_src js
function handleKeyDown(event) {
    let action = handleKeys(event.keyCode);
    if (action) {
        if (action[0] === 'move') {
            let [_, dx, dy] = action;
            let newX = player.x + dx,
                newY = player.y + dy;
            if (map.get(newX, newY) === 0) {
                player.x = newX;
                player.y = newY;
            }
            draw();
        } else {
            throw `unhandled action ${action}`;
        }
        event.preventDefault();
    }
}
#+end_src

The dungeon generation algorithm also generates a list of rooms and corridors. This might be useful later.

* Field of view

ROT.js includes [[https://ondras.github.io/rot.js/manual/#fov][two field of view algorithms]]. The field of view library is fairly easy to use. The /input/ callback lets it /ask/ you “can you see through x,y?” and the /output/ callback lets it /tell/ you “there's this much light at x,y”. I saved the results in a Map and used it for calculating the light level at any point. The Python tutorial doesn't use the light level but maybe I'll find something to do with it later.

#+begin_src js
const fov = new ROT.FOV.PreciseShadowcasting((x, y) => map.get(x, y) === 0);

function draw() {
    display.clear();

    let lightMap = new Map();
    fov.compute(player.x, player.y, 10, (x, y, r, visibility) => {
        lightMap.set(map.key(x, y), visibility);
    });
                
    const colors = {
        [false]: {[false]: "rgb(50, 50, 150)", [true]: "rgb(0, 0, 100)"},
        [true]: {[false]: "rgb(200, 180, 50)", [true]: "rgb(130, 110, 50)"}
    };
    for (let y = 0; y < map.height; y++) {
        for (let x = 0; x < map.width; x++) {
            let lit = lightMap.get(map.key(x, y)) > 0.0,
                wall = map.get(x, y) !== 0;
            let color = colors[lit][wall];
            display.draw(x, y, ' ', "black", color);
        }
    }
    for (let entity of entities.values()) {
        if (lightMap.get(map.key(entity.x, entity.y)) > 0.0) {
            drawEntity(entity);
        }
    }
}
#+end_src

Ok, this seems like it's not too hard. Looks cool:

[[./screenshots/6.png]]

But there's a problem: the entities (=@= and =T=) are getting drawn with a black background color, not with the map background. In libtcod, I can set the background and foreground separately, so in the official tutorial the map sets the background and the entity sets the foreground and character. In ROT.js, I have to set all three at once.

I need to merge my drawing loops somehow.

I'm going to remove the =drawEntity()= function and replace it with a lookup function. Instead of drawing to the screen it only tells the =draw()= function what to draw.

#+begin_src js
/** return [char, fg, optional bg] for a given entity */
function entityGlyph(entityType) {
    const visuals = {
        player: ['@', "hsl(60, 100%, 70%)"],
        troll: ['T', "hsl(120, 60%, 30%)"],
        orc: ['o', "hsl(100, 30%, 40%)"],
    };
    return visuals[entityType];
}
#+end_src

Now the draw function has more logic, because it's merging the entity glyph with the map background color:

#+begin_src js
function draw() {
    display.clear();

    let lightMap = new Map(); // map key to 0.0–1.0
    fov.compute(player.x, player.y, 10, (x, y, r, visibility) => {
        lightMap.set(map.key(x, y), visibility);
    });

    let glyphMap = new Map(); // map key to [char, fg, optional bg]
    for (let entity of entities.values()) {
        glyphMap.set(map.key(entity.x, entity.y), entityGlyph(entity.type));
    }
    
    const mapColors = {
        [false]: {[false]: "rgb(50, 50, 150)", [true]: "rgb(0, 0, 100)"},
        [true]: {[false]: "rgb(200, 180, 50)", [true]: "rgb(130, 110, 50)"}
    };
    for (let y = 0; y < map.height; y++) {
        for (let x = 0; x < map.width; x++) {
            let lit = lightMap.get(map.key(x, y)) > 0.0,
                wall = map.get(x, y) !== 0;
            let ch = ' ',
                fg = "black",
                bg = mapColors[lit][wall];
            let glyph = glyphMap.get(map.key(x, y));
            if (glyph) {
                ch = lit? glyph[0] : ch;
                fg = glyph[1];
                bg = glyph[2] || bg;
            }
            display.draw(x, y, ch, fg, bg);
        }
    }
}
#+end_src

Now the background colors behind entities look reasonable:

[[./screenshots/7.png]]

The background color comes from the map and the foreground color and character comes from the entity.

The next step is to implement the /three/ states of the map:

1. Unexplored: don't show anything.
2. Explored, but not currently visible: show in blue.
3. Visible: show in yellow.

For this I'll add a flag =explored= to the map. It will start out false and become true if the tile is /ever/ visible. I realized that my map object isn't great. It has a =get= and =set= but that is returning 0 for a floor and 1 for a tile. I also have other similar types of maps like =lightMap= and a =glyphMap=.

I'm going to make a wrapper around 2d maps from (x,y) to any value:

#+begin_src js
function createMap(initializer) {
    function key(x, y) { return `${x},${y}`; }
    return {
        _values: new Map(),
        at(x, y) {
            let k = key(x, y);
            if (!this._values.has(k)) { this._values.set(k, initializer()); }
            return this._values.get(k);
        },
    };
}
#+end_src

I replaced my game map data structure with the generic one:

#+begin_src js
function createTileMap(width, height) {
    let tileMap = createMap();
    const digger = new ROT.Map.Digger(width, height);
    digger.create((x, y, contents) =>
        tileMap.set(x, y, {
            walkable: contents === 0,
            wall: contents === 1,
            explored: false,
        })
    );
    return tileMap;
}
#+end_src

A note about data structure: I used to fall into a loop. I would put a /lot/ of effort into the core data structures, figuring out class hierarchies, modules, extensibility, generics, patterns, etc. Then I would /use/ it for a bit and realize something isn't great. But I wouldn't change it because I had put /so much effort/ into it that it was really hard to justify throwing anything away.

These days I /don't start/ with the right data structures. Instead, I start with /something/ and then plan to change it once I figure out what I want. I /discover/ the best patterns while working on the project, instead of /starting/ with the patterns and then making the project fit. Because I put so little effort into the initial code, it's no big deal to throw it out and replace it with something better.

I changed the data structures for this project four times already, and it was still faster than if I had tried to figure out everything ahead of time. I'm optimizing for /making it easy to make changes/.

Now that I have a 2d sparse map data structure, I'll reuse it for the light and glyph maps. While calculating the light map, I also update the =explored= flag in the tile map. Another possible design would be to keep a separate =exploredMap= instead of modifying the tile map; that would allow for multiple explored maps corresponding to different player characters. But this will do for now.

#+begin_src js
function computeLightMap(center, tileMap) {
    let lightMap = createMap(); // 0.0–1.0
    fov.compute(center.x, center.y, 10, (x, y, r, visibility) => {
        lightMap.set(x, y, visibility);
        if (visibility > 0.0) {
            if (tileMap.has(x, y))
            tileMap.get(x, y).explored = true;
        }
    });
    return lightMap;
}

function computeGlyphMap(entities) {
    let glyphMap = createMap(); // [char, fg, optional bg]
    for (let entity of entities.values()) {
        glyphMap.set(entity.x, entity.y, entityGlyph(entity.type));
    }
    return glyphMap;
}
#+end_src

Here's the new =draw()= function:

#+begin_src js
const mapColors = {
    [false]: {[false]: "rgb(50, 50, 150)", [true]: "rgb(0, 0, 100)"},
    [true]: {[false]: "rgb(200, 180, 50)", [true]: "rgb(130, 110, 50)"}
};
function draw() {
    display.clear();

    let lightMap = computeLightMap(player, tileMap);
    let glyphMap = computeGlyphMap(entities);
    
    for (let y = 0; y < HEIGHT; y++) {
        for (let x = 0; x < WIDTH; x++) {
            let tile = tileMap.get(x, y);
            if (!tile || !tile.explored) { continue; }
            let lit = lightMap.get(x, y) > 0.0;
            let ch = ' ',
                fg = "black",
                bg = mapColors[lit][tile.wall];
            let glyph = glyphMap.get(x, y);
            if (glyph) {
                ch = lit? glyph[0] : ch;
                fg = glyph[1];
                bg = glyph[2] || bg;
            }
            display.draw(x, y, ch, fg, bg);
        }
    }
}
#+end_src

And hey, it works!

[[./screenshots/8.png]]

* Enemies

Part 5 of the Python tutorial adds monsters to rooms.

One of the things the Python tutorial uses is the Python =randint()= function. [[https://ondras.github.io/rot.js/manual/#rng][ROT.js's manual]] shows that it has =getUniform()=, which I can wrap to make a =randint()= function. However if you dig deeper, [[https://ondras.github.io/rot.js/doc/classes/_rng_.rng.html#getuniformint][ROT.js actually has the randint function]], called =getUniformInt()=. There seem to be a lot of things that /aren't covered in the manual/.

I made a shortcut for it:

#+begin_src js
const randint = ROT.RNG.getUniformInt.bind(ROT.RNG);
#+end_src

and then used it for the monster creating function:

#+begin_src js
function createMonsters(room, maxMonstersPerRoom) {
    let numMonsters = randint(0, maxMonstersPerRoom);
    for (let i = 0; i < numMonsters; i++) {
        let x = randint(room.getLeft(), room.getRight()),
            y = randint(room.getTop(), room.getBottom());
        if (!entityAt(x, y)) {
            let type = randint(0, 3) === 0? 'troll' : 'orc';
            createEntity(type, x, y);
        }
    }
}
#+end_src

But what is a room? The ROT.js dungeon digger records room objects in addition to tiles. I stored these in the =tileMap= for now.

#+begin_src js
function createTileMap(width, height) {
    let tileMap = createMap();
    const digger = new ROT.Map.Digger(width, height);
    digger.create(…);
    tileMap.rooms = digger.getRooms();
    tileMap.corridors = digger.getCorridors();
    return tileMap;
}
#+end_src

and then used them to make monsters in each room:

#+begin_src js
for (let room of tileMap.rooms) {
    createMonsters(room, 3);
}
#+end_src

Cool, it works! (Note: I disabled FOV for this screenshot)

[[./screenshots/9.png]]

Or … does it? Why are they all orcs?! I thought there must be a bug in my code, but no, it's just random luck. If I change the seed I get both trolls and orcs.

[[./screenshots/10.png]]

The next step is that they add a =blocks= flag to each Entity. I decided to make that a property of the entity /type/.

#+begin_src js
const ENTITY_PROPERTIES = {
    player: {blocks: true, visuals: ['@', "hsl(60, 100%, 70%)"],},
    troll: {blocks: true, visuals: ['T', "hsl(120, 60%, 30%)"],},
    orc: {blocks: true, visuals: ['o', "hsl(100, 30%, 40%)"],},
};
#+end_src

As I mentioned earlier, I'll often do something and then change how it works later. I'm replacing the =entityGlyph()= function with this table.

I modified the =handleKeyDown()= function to check if there's already an entity there:

#+begin_src js
…
    let newX = player.x + dx,
        newY = player.y + dy;
    if (tileMap.get(newX, newY).walkable) {
        let target = entityAt(newX, newY);
        if (target && ENTITY_PROPERTIES[target.type].blocks) {
            console.log(`You kick the ${target.type} in the shins, much to its annoyance!`);
            // TODO: draw this to the screen
        } else {
            player.x = newX;
            player.y = newY;
        }
    }
…
#+end_src

I tested this and it worked. Moving into a monster prints an message to the console.

The next section in the Python tutorial sets up a state =PLAYER_TURN= and =ENEMY_TURN=. I didn't like the way it worked, because it will /ignore/ the player keypress during the enemy turn. I don't quite know what I want to do about it.

I think for now I'll have the enemies move after each player move. I moved the above code into its own function:

#+begin_src js
function enemiesMove() {
    for (let entity of entities) {
        if (entity !== player) {
            console.log(`The ${entity.type} ponders the meaning of its existence.`);
        }
    }
}
#+end_src

Since my random number generator produced all orcs, I get a /lot/ of console messages:

#+begin_example
The orc ponders the meaning of its existence.
#+end_example

Great! Before I move on to the next part of the tutorial, I wanted to add a way to see the messages under the game screen.

* Console

I updated the UI to have an extra div for messages, and put the instructions box below it. This is covered in the Python tutorial part 7, but I implemented it earlier:

#+begin_src xml
<figure>
  <div id="game"></div>
  <pre id="messages"></pre>
  <div id="instructions"/>
</figure>
#+end_src

I gave it some style:

#+begin_src css
#messages {
    box-sizing: border-box;
    font-size: 0.8em;
    height: 6em; /* see explanation below */
    line-height: 1.0;
    background: black;
    color: white;
    margin: 0;
    padding: 0.5em 1em;
    text-align: left;
}
#+end_src

The size calculation was a little tricky. I want the height to be 5 lines tall. A line is typically =line-height= times =font-size=. I set the line height to 1.0 so it seems like the height will be 1.0 * 0.8em * 5 = 4em. But it's not! The css for =<pre>= em is relative to the =<pre>='s font size, except for =font-size: 0.8em= which is relative to the parent =<figure>='s font size. So it's really 1.0 * 1em = 5em. Plus, with =box-sizing: border-box= I need to include the size of the padding. Both the top and bottom padding are 0.5em here so that means the total height of the box is 6em.

Ok, and here's the Javascript to print a line of text to the message area:

#+begin_src js
function print(message) {
    const MAX_LINES = 5;
    let messages = document.querySelector("#messages");
    let lines = messages.textContent.split("\n");
    lines.push(message);
    while (lines.length > MAX_LINES) { lines.shift(); }
    messages.textContent = lines.join("\n");
}
#+end_src

And here's the updated code for the instructions box, which used to hide/show "Click game to focus" but now replaces that text with "Arrow keys to move":

#+begin_src js
function setupKeyboardHandler(display, handler) {
    const canvas = display.getContainer();
    const instructions = document.getElementById('instructions');
    canvas.setAttribute('tabindex', "1");
    canvas.addEventListener('keydown', handleKeyDown);
    canvas.addEventListener('blur', () => { instructions.textContent = "Click game for keyboard focus"; });
    canvas.addEventListener('focus', () => { instructions.textContent = "Arrow keys to move"; });
    canvas.focus();
}
#+end_src

Here's what it looks like:

[[./screenshots/11.png]]

Back to the Python tutorial.


* Combat

[[http://rogueliketutorials.com/tutorials/tcod/part-6/][Part 6]] of the Python roguelike tutorial adds a “fighter” component with hp, max_hp, defense, power, and an “ai” component that tells the monster how to move.

This is the part of the tutorial where the real game logic starts. My goal is to implement the /features/ from the Python tutorial, but not necessarily with the same code structure.

My own coding style is to prefer separating “static” from “instance” data and functions. Static properties are part of /the game/. Instance properties are part of /running the game/. For example, the troll's color is a static property of the troll. The color is decided before any trolls exist. It is the /same/ for all trolls, but it might be /different/ if I change the program code. A position is an instance property of the troll. It is /different/ for each troll, but it'll be the /same/ if I load the save file in new version of the game. 

I also prefer to use “free functions” (static) and “plain old data” (instance) instead of combining them into classes. It makes things like persistence and multiplayer easier for me to implement. I'm going to do this not only for the entity but also the fighter and ai components. 

For the entities, I put the static properties into a =ENTITY_PROPERTIES= lookup table, and I used Javascript prototype inheritance to attach it to each entity.

For the fighter and AI, I decided to look ahead in the tutorial to see how they will get used. 

- For the fighter, I was planning to treat =defense= and =power= and =max_hp= as static properties, and =hp= as a per object property, but it looks like =defense= and =power= and =max_hp= all become computed properties, so maybe this is a premature design decision. The =attack()= function seems to be the same for all entities so I think I'll leave it out of the entity/component (in ECS it'd be a "system"). I'm seeing no particular value in making this a separate component right now. 
- For the AI, it's either a basic monster that moves towards the player, or a confused monster that moves randomly for some number of turns and then reverts to the previous AI behavior. I think I could treat that as a function, but functions don't work well with persistence, so I'm going to treat it as data that has a =type= field, like I did with entities.

I'm going to see how far I can get without adding an =owner= pointer. I strongly prefer not to have it, because it leads to a circularity in the data, which will make persistence more complicated. In an ECS this circularity would be broken by storing an entity id instead of a pointer to the entity object, but I'm not using an ECS here.

Here's an example of a top level function that's not a method of either the attacker or defender:

#+begin_src js
function attack(attacker, defender) {
    let damage = attacker.power - defender.defense;
    if (damage > 0) {
        takeDamage(defender, damage);
        print(`${attacker.type} attacks ${defender.type} for ${damage} hit points.`);
    } else {
        print(`${attacker.type} attacks ${defender.type} but does no damage.`);
    }
}
#+end_src

[[./screenshots/12.png]]

I added the fighter and ai components, but not in the same way the Python tutorial implemented them. I'll refactor later.

Then I implemented rendering order as a static property of each entity.

Then I worked on handling dead bodies. I change their =type= to =corpse= to get them to switch all static properties (=blocks=, character, color, render order) at once.

It's starting to come together!

[[./screenshots/13.png]]

* Health bar

[[http://rogueliketutorials.com/tutorials/tcod/part-7/][Part 7]] of the Python tutorial covers three topics:

1. health bar
2. message area
3. entity info on mouseover

I already implemented the message area earlier. It's in HTML instead of in ROT.js. I'm going to implement the health bar in HTML as well.

[[./screenshots/14.png]]

* Message area, part 2

I also improved the message area:

1. added color by switching from =<pre>= to a =<div>= with =<div>= children, each with a css =color: …= set
2. got word-wrap for free by making this switch!
3. added indentation by applying css =margin-left: 1em; indent-text: -1em;= so that a message that wraps will get subsequent lines indented
4. added scrolling by setting css =overflow-x: hidden; overflow-y: scroll= but hid the scrollbar using =scrollbar-width: none= ([[https://caniuse.com/#search=scrollbar-width][Firefox supports the standard]]) and =::-webkit-scrollbar { width: 0 }= (Chrome and Safari naturally have their own non-standard approach)
5. added a spacing between the messages with =margin-bottom: 0.25em= so that the line spacing within messages is smaller than between messages

[[./screenshots/15.png]]

Version 2 of the Python tutorial also adds a way to scroll the message area, integrated into its event loop. The browser gives me that for free, although it's mouse based and not keyboard based like the Python version. Version 2 also adds message stacking, but I didn't implement that either.

I think it wouldn't be hard to add color /within/ lines. I did that with [[http://www-cs-students.stanford.edu/~amitp/Articles/SRE-Documentation.html][my DOS games]] and liked the effect. But for now I'm sticking to implementing the features from version 1 of the Python tutorial.

* Mouse info

The Python tutorial fits the mouse handling into the main event loop but the browser has its own event loop, so I deviated from the tutorial's approach.

First question is: where do I want to display this information? I decided to use CSS grid to display it over the message console. Here's the HTML:

#+begin_src xml
  <div id="message-area">
    <div id="messages"/>
    <div id="message-overlay"/>
  </div>
#+end_src

Normally this would be laid out with the message console (=#messages=) first and then the next div afterwards. But with CSS grid I put them in the same spot:

#+begin_src css
      #message-area {
          margin: auto;
          display: grid;
          grid-template-areas: "all";
          height: 8em;
          font-family: monospace;
          font-size: 0.8em;
          line-height: 1.0;
      }
      #messages {
          grid-area: all;
          …
      }
      #message-overlay {
          grid-area: all;
          z-index: 2; /* workaround for chrome */
          opacity: 0.0;
          background: hsl(200, 50%, 30%);
          color: white;
          white-space: pre-wrap;
      }
      #message-overlay.visible {
          opacity: 1.0;
      }
#+end_src

Then in the code, I set the opacity to 1 if there's text and 0 if not:

#+begin_src js
const setOverlayMessage = (() => {
    let area = document.querySelector("#message-overlay");
    return function(text) {
        area.textContent = text;
        area.setAttribute("class", text? "visible" : "");
    };
})();
#+end_src

This works nicely! /Except/ on Chrome, where it works initially but then fails later for reasons I couldn't figure out. By adding =z-index: 2= to the overlay, it worked, but I don't understand /why/.

The next step is to attach a =mousemove= listener to the =<canvas>=. I didn't integrate into the main game loop, but instead have this running independently.

Not mentioned in the ROT.js interactive manual, ROT.js's display class has a useful method =eventToPosition=, documented [[https://ondras.github.io/rot.js/doc/classes/_display_display_.display.html#eventtoposition][here]]. It takes a mouse event and gives us back a grid tile location. If it returns =[-1, -1]= it was out of range (which seems like it should never happen, but does).

#+begin_src js
function allEntitiesAt(x, y) {
    return Array.from(entities.values()).filter(e => e.x === x && e.y === y);
}

function handleMousemove(event) {
    let [x, y] = display.eventToPosition(event); // returns -1, -1 for out of bounds
    let entities = allEntitiesAt(x, y);
    let text = entities.map(e => e.name).join("\n");
    setOverlayMessage(text);
}

function handleMouseout(event) {
    setOverlayMessage("");
}

const canvas = display.getContainer();
canvas.addEventListener('mousemove', handleMousemove);
canvas.addEventListener('mouseout', handleMouseout);
#+end_src

Hooray, it works!

[[./screenshots/16.png]]

This feature was relatively easy to implement.

But … this broke the message area scrolling! The problem is that the scroll mouse event gets sent to the overlay, even when its opacity is 0.0. I fixed this by adding CSS:

#+begin_src css
      #message-overlay {
          …
          pointer-events: none;
      }
#+end_src

While I was at it, I also added a fade-out effect using =transition: all 0.3s= to =#message-overlay= and =transition: all 0s= to =#message-overlay.visible=. When making the overlay visible, it will have no transition (0s) but when making the overlay invisible it will use a quick transition (0.3s).

* Items and inventory

Part 8 of the Python tutorial covers items and inventory. I decided to use a different representation than they use. To pick up an item, they /remove/ the entity from the global =entities= array, and then ignore the =x= and =y= fields on it.

- instead of entities having =x= and =y=, they have =location=, which can be either
  - ={x:int, y:int}= if the entity is on the map, or
  - ={carried:id, slot:int}= if the entity is in someone's inventory.
- instead of inventory having =capacity:int= and =items:Array<object>=, the inventory is a fixed length =Array<null|id>=, with the length being the capacity.

In the Python tutorial, if you pick up a potion of healing, then pick up a potion of confusion, they will be assigned keys ~a~ and ~b~. If you drop the first potion, then the potion of confusion changes from ~b~ to ~a~. I like the Brogue approach, where an item keeps its key, so I represented the inventory as a fixed size array where each slot can contain an item or null.

The logic for this is slightly tricky because there are two systems that have to be kept in sync. To pick up an item, I need to update both the item's data and the carrier's data:

- item =A=: ={carried: E.id, slot: P}=
- entity =E=: ={inventory: […, A.id, …]}= where that id is in position =P=

And to drop the item I need to update both again:

- item: =A=: ={x: x, y: y}=
- entity =E=: ={inventory: […, null, …]}=

What happens if the entity is consumed? I haven't decided yet.

I wanted to encapsulate the logic for keeping this data in sync, so I wrote a function:

#+begin_src js
function moveEntityTo(entity, location) {
    if (entity.location.carried !== undefined) {
        let {carried, slot} = entity.location;
        let carrier = entities.get(carried);
        if (carrier.inventory[slot] !== entity.id)
            throw `invalid: inventory slot ${slot} contains ${carrier.inventory[slot]} but should contain ${entity.id}`;
        carrier.inventory[slot] = null;
    }
    entity.location = location;
    if (entity.location.carried !== undefined) {
        let {carried, slot} = entity.location;
        let carrier = entities.get(carried);
        if (carrier.inventory === undefined)
            throw `invalid: moving to an entity without inventory`;
        if (carrier.inventory[slot] !== null)
            throw `invalid: inventory already contains an item ${carrier.inventory[slot]} in slot ${slot}`;
        carrier.inventory[slot] = entity.id;
    }
    // TODO: add constraints for at most one (player|monster) and at most one (item) in any {x, y}
}
#+end_src

This logic is tricky enough that I want to make sure I have plenty of assertions in there!

* Inventory UI

Part 8 also introduces an inventory UI. Since the browser already provides multiple UI elements, I wanted to try using them instead of creating my own as the Python version is forced to do. I created a new overlay ~<div id="inventory-overlay">~ and hid it when not in use.

[[./screenshots/17.png]]

I had hoped to try using the focused element status from the browser to keep track of whether the main game had focus or the inventory dialog had focus, but that ended up being more complicated than I wanted to tackle right now. The main problem is that the user may change the focus with the browser controls (mouse or keyboard) instead of going through the game's controls and then I need to handle that somehow.

#+begin_export html
<x:footer>
  <style>
      .figure img { 
          display: block; 
          margin: auto; 
          border: 2px solid #999; 
          box-shadow: 0 1px 2px 2px rgba(0,0,0,0.2); 
      }

      figure {
          text-align: left;
          display: grid;
          justify-content: center;
          grid-template-columns: min-content;
          grid-template-areas: "game" "status-bar" "message-area" "instructions";
      }
      canvas#game { 
          grid-area: game;
          z-index: 1;
          display: block;
          max-width: unset;
          opacity: 0.5;
      }
      canvas#game:focus {
          outline: none;
          opacity: 1.0;
      }

      #inventory-overlay {
          grid-area: game;
          z-index: 0;
          height: auto;
          align-self: center;
          padding: 0.5em;
          line-height: 1.0;
          font-family: monospace;
          font-size: 0.8em;
          opacity: 0;
          background: hsl(60, 10%, 20%);
          color: white;
      }
      #inventory-overlay.visible {
          z-index: 2;
          opacity: 1;
      }
      #inventory-overlay ul {
          column-count: 2;
          column-gap: 1em;
          column-fill: balance;
      }
      #inventory-overlay li {
          list-style-type: none;
      }
      #inventory-overlay kbd {
          display: inline-block;
          border: 1px solid hsl(150, 60%, 30%);
          padding: 2px 4px;
          background: hsl(150, 50%, 30%);
          font-weight: normal;
          color: yellow;
      }

      #instructions {
          height: 1.2em;
          grid-area: instructions;
          text-align: center;
      }

      #messages, #message-overlay {
          grid-area: message-area;
          width: 100%;
          height: 8em;
          font-family: var(--monospace), monospace;
          font-size: 0.8em;
          line-height: 1.0;
      }
      #messages {
          padding: 0.5em 1em;
          background: hsl(60, 10%, 10%);
          color: white;
          overflow-x: hidden;
          overflow-y: scroll;
          scrollbar-width: none; /* firefox supports the standard */
      }
      #messages::-webkit-scrollbar { /* but chrome, safari do not, naturally */
          width: 0;
      }
      #messages > div {
          margin-left: 1em;
          margin-bottom: 0.25em;
          text-indent: -1em;
      }
      #messages > div.welcome       { color: hsl(220,  50%,  70%); }
      #messages > div.player-attack { color: hsl( 30,  10%,  80%); }
      #messages > div.player-die    { color: hsl(  0, 100%,  50%); }
      #messages > div.enemy-attack  { color: hsl(  0,  50%,  80%); }
      #messages > div.enemy-die     { color: hsl(150,  30%,  70%); }
      #messages > div.warning       { color: hsl( 60,  50%,  70%); }
      #messages > div.pick-up       { color: hsl(220,  50%,  80%); }
      #messages > div.healing       { color: hsl(150,  50%,  70%); }

      #message-overlay {
          z-index: 2; /* needed for chrome but not firefox or safari; may be a browser bug */
          height: 0%;
          padding: 0.5em 1em;
          opacity: 0.0;
          pointer-events: none; /* so scroll events go down to the #messages div */
          white-space: pre-wrap;
          background: black;
          color: white;
          transition: all 0.3s;
      }
      #message-overlay.visible {
          height: 100%;
          opacity: 1.0;
          background: hsl(200, 50%, 30%);
          transition: all 0s;
      }

      #status-bar {
          grid-area: status-bar;
          width: 100%;
          background: hsl(0, 50%, 20%);
      }
      #health-bar {
          grid-area: status-bar;
          background: hsl(200, 50%, 40%);
      }
      #health-text {
          grid-area: status-bar;
          font-size: 0.8em;
          font-family: var(--sans-serif), sans-serif;
          color: white;
          text-align: center;
      }
  </style>
  <script src="third-party/rot.js"></script>
  <script src="roguelike-dev.js"></script>

  Created 18 Jun 2020; &#160;
  <!-- hhmts start -->Last modified: 19 Jul 2020<!-- hhmts end -->
</x:footer>
#+end_export
